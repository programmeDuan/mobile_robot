一、RealTimeCorrelativeScanMatching类，它的主要作用就是帧间匹配。流程如下：

1）把空间划分成栅格

2）根据每个栅格内时候有激光点，给每个栅格一直占栅格值

3）计算当前帧和局部地图的占栅格值

4）对当前帧设置一个search window，即一个平移（x、y）和旋转（航向）的区间

5）把search window划分成多个选择项，每一个选择项对应一个位姿，即x、y、航向角

6）对每个备选位姿，按照它转换当前帧，和局部地图去计算一个匹配程度的指标，这个指标就是根据栅格值之间差别计算方法，方差越大，则越不匹配

7）找出匹配度最高的那个，即可认为是当前位姿

这样做其实就是暴力搜索了，明显会影响效率，所以论文中又增加了一步操作，就是多分辨率，先生成低分辨率栅格，低分辨率栅格对应的search window
自然就比较粗放，这样搜索次数就少，当搜索出一个粗略的值之后，再用高分辨率搜索精确的值，这样可以节省时间。

在实际代码中，RealTimeCorrelativeScanMatching这个类并没有使用多分辨率这个方法，因为它主要是使用在前端的帧间匹配过程中，这个时候预测的位
姿其实已经相对比较准了，即使暴力搜索也不会太消耗时间。

真正使用多分辨率的是一个叫FastCorrelativeScanMatching的类，它主要用来做闭环，所以接受不了暴力搜索。而且，为了进一步提高效率，
还用了分枝定界，

二、栅格地图
cartographer所有的匹配方法都是基于栅格地图的，所以要介绍匹配，首先介绍其栅格方法。

栅格方法很好理解，把空间划分成同等大小的栅格，针对落在栅格内点的个数多少，给这个栅格计算一个值。匹配是当前帧和局部地图（submap）的匹配，
所以对二者都用下面这个公式进行栅格计算：
